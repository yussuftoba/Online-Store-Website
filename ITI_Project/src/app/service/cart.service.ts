import { Injectable } from '@angular/core'; // Makes the service available for dependency injection
import { HttpClient } from '@angular/common/http'; // Used to make HTTP requests
import { ProductService } from './product.service'; // (Not used in this file â€“ could be removed)
import { switchMap, take } from 'rxjs'; // RxJS operators for handling observable streams

// Interface to define the structure of a cart item
export interface CartItem {
  id?: number;              // Optional ID (generated by backend)
  productId: number;        // ID of the associated product
  productImage: string;     // URL or path of product image
  name: string;             // Product name
  price: number;            // Product price
  quantity: number;         // Quantity of this product in cart
}

// Decorator marks this service as injectable and provided globally (singleton)
@Injectable({ providedIn: 'root' })
export class CartService {
  // Base URLs for cart and products JSON server endpoints
  private cartApiUrl = 'http://localhost:3000/cart';
  private productsApiUrl = 'http://localhost:3000/products';

  // Inject Angular's HttpClient to perform HTTP operations
  constructor(private http: HttpClient) { }

  // Fetch all items in the cart
  getAll() {
    return this.http.get<CartItem[]>(this.cartApiUrl);
  }

  // Add a product to the cart or increase quantity if already exists
  addToCart(cartItem: any) {
    this.getAll().subscribe(items => {
      // Check if the product already exists in cart
      const existingItem = items.find(i => i.productId === cartItem.productId);

      if (existingItem) {
        // If it exists, increment the quantity
        return this.updateQuantity(existingItem.id!, existingItem.productId, existingItem.quantity + 1).subscribe();
      } else {
        // If not, create a new CartItem object with quantity 1
        const item: CartItem = {
          productId: cartItem.productId,
          productImage: cartItem.productImage,
          name: cartItem.name,
          price: cartItem.price,
          quantity: 1
        };

        // Post the new item to the cart
        return this.http.post<CartItem>(this.cartApiUrl, item).subscribe();
      }
    });
  }

  // Update the quantity of an existing cart item (with stock check)
  updateQuantity(itemId: number, productId: number, newQuantity: number) {
    // First fetch the product to check its stock
    return this.http.get<{ stock: number }>(`${this.productsApiUrl}/${productId}`)
      .pipe(
        take(1), // Take only the first response and complete
        switchMap(product => {
          // Only update if the new quantity is within stock limit
          if (newQuantity <= product.stock){
            // Update quantity via PATCH and then return updated cart
            return this.http.patch(`${this.cartApiUrl}/${itemId}`, {quantity: newQuantity})
              .pipe(switchMap(() => this.getAll()));
          } else {
            // If quantity exceeds stock, just return the current cart without change
            return this.getAll();
          }
        })
      );
  }

  // Remove a single item from the cart by its ID
  removeFromCart(itemId: number) {
    return this.http.delete(`${this.cartApiUrl}/${itemId}`);
  }

  // Clear the entire cart by deleting all items one by one
  clearCart() {
    // First, fetch all items
    this.http.get<CartItem[]>(this.cartApiUrl).subscribe(items => {
      // Loop through each item and delete it
      items.forEach(item => {
        this.removeFromCart(item.id!).subscribe();
      });
    });
  }
}
